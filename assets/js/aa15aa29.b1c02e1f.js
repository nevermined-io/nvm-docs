"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[2753],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>p});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),d=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},c=function(e){var t=d(e.components);return a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),m=d(n),p=r,h=m["".concat(l,".").concat(p)]||m[p]||u[p]||o;return n?a.createElement(h,s(s({ref:t},c),{},{components:n})):a.createElement(h,s({ref:t},c))}));function p(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,s=new Array(o);s[0]=m;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:r,s[1]=i;for(var d=2;d<o;d++)s[d]=n[d];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},85162:(e,t,n)=>{n.d(t,{Z:()=>s});var a=n(67294),r=n(86010);const o="tabItem_Ymn6";function s(e){let{children:t,hidden:n,className:s}=e;return a.createElement("div",{role:"tabpanel",className:(0,r.default)(o,s),hidden:n},t)}},74866:(e,t,n)=>{n.d(t,{Z:()=>N});var a=n(87462),r=n(67294),o=n(86010),s=n(12466),i=n(16550),l=n(91980),d=n(67392),c=n(50012);function u(e){return function(e){return r.Children.map(e,(e=>{if((0,r.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))}(e).map((e=>{let{props:{value:t,label:n,attributes:a,default:r}}=e;return{value:t,label:n,attributes:a,default:r}}))}function m(e){const{values:t,children:n}=e;return(0,r.useMemo)((()=>{const e=t??u(n);return function(e){const t=(0,d.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,n])}function p(e){let{value:t,tabValues:n}=e;return n.some((e=>e.value===t))}function h(e){let{queryString:t=!1,groupId:n}=e;const a=(0,i.k6)(),o=function(e){let{queryString:t=!1,groupId:n}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:t,groupId:n});return[(0,l._X)(o),(0,r.useCallback)((e=>{if(!o)return;const t=new URLSearchParams(a.location.search);t.set(o,e),a.replace({...a.location,search:t.toString()})}),[o,a])]}function f(e){const{defaultValue:t,queryString:n=!1,groupId:a}=e,o=m(e),[s,i]=(0,r.useState)((()=>function(e){let{defaultValue:t,tabValues:n}=e;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!p({value:t,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const a=n.find((e=>e.default))??n[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:t,tabValues:o}))),[l,d]=h({queryString:n,groupId:a}),[u,f]=function(e){let{groupId:t}=e;const n=function(e){return e?`docusaurus.tab.${e}`:null}(t),[a,o]=(0,c.Nk)(n);return[a,(0,r.useCallback)((e=>{n&&o.set(e)}),[n,o])]}({groupId:a}),y=(()=>{const e=l??u;return p({value:e,tabValues:o})?e:null})();(0,r.useLayoutEffect)((()=>{y&&i(y)}),[y]);return{selectedValue:s,selectValue:(0,r.useCallback)((e=>{if(!p({value:e,tabValues:o}))throw new Error(`Can't select invalid tab value=${e}`);i(e),d(e),f(e)}),[d,f,o]),tabValues:o}}var y=n(72389);const g="tabList__CuJ",b="tabItem_LNqP";function v(e){let{className:t,block:n,selectedValue:i,selectValue:l,tabValues:d}=e;const c=[],{blockElementScrollPositionUntilNextRender:u}=(0,s.o5)(),m=e=>{const t=e.currentTarget,n=c.indexOf(t),a=d[n].value;a!==i&&(u(t),l(a))},p=e=>{var t;let n=null;switch(e.key){case"Enter":m(e);break;case"ArrowRight":{const t=c.indexOf(e.currentTarget)+1;n=c[t]??c[0];break}case"ArrowLeft":{const t=c.indexOf(e.currentTarget)-1;n=c[t]??c[c.length-1];break}}null==(t=n)||t.focus()};return r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.default)("tabs",{"tabs--block":n},t)},d.map((e=>{let{value:t,label:n,attributes:s}=e;return r.createElement("li",(0,a.Z)({role:"tab",tabIndex:i===t?0:-1,"aria-selected":i===t,key:t,ref:e=>c.push(e),onKeyDown:p,onClick:m},s,{className:(0,o.default)("tabs__item",b,null==s?void 0:s.className,{"tabs__item--active":i===t})}),n??t)})))}function k(e){let{lazy:t,children:n,selectedValue:a}=e;if(n=Array.isArray(n)?n:[n],t){const e=n.find((e=>e.props.value===a));return e?(0,r.cloneElement)(e,{className:"margin-top--md"}):null}return r.createElement("div",{className:"margin-top--md"},n.map(((e,t)=>(0,r.cloneElement)(e,{key:t,hidden:e.props.value!==a}))))}function w(e){const t=f(e);return r.createElement("div",{className:(0,o.default)("tabs-container",g)},r.createElement(v,(0,a.Z)({},e,t)),r.createElement(k,(0,a.Z)({},e,t)))}function N(e){const t=(0,y.Z)();return r.createElement(w,(0,a.Z)({key:String(t)},e))}},39104:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>l,default:()=>p,frontMatter:()=>i,metadata:()=>d,toc:()=>u});var a=n(87462),r=(n(67294),n(3905)),o=n(74866),s=n(85162);const i={sidebar_position:4},l="How to use Nevermined NFTs via SDK",d={unversionedId:"nevermined-sdk/nfts-sdk",id:"nevermined-sdk/nfts-sdk",title:"How to use Nevermined NFTs via SDK",description:"We are gonna see how to use Nevermined NFTs using the SDK-JS. Before starting it\u2019s recommended you take a look at the Getting Started documentation page where you will be able to find information about how to install the library and initialize it.",source:"@site/docs/nevermined-sdk/nfts-sdk.md",sourceDirName:"nevermined-sdk",slug:"/nevermined-sdk/nfts-sdk",permalink:"/docs/nevermined-sdk/nfts-sdk",draft:!1,editUrl:"https://github.com/nevermined-io/docs/tree/main/docs/nevermined-sdk/nfts-sdk.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"How to use the SDK?",permalink:"/docs/nevermined-sdk/example"},next:{title:"Compute Example",permalink:"/docs/nevermined-sdk/compute-example"}},c={},u=[{value:"Deploying and connecting to your own NFT contract",id:"deploying-and-connecting-to-your-own-nft-contract",level:2},{value:"Cloning a previously deployed contract",id:"cloning-a-previously-deployed-contract",level:3},{value:"Deploying a Nevermined NFT contract",id:"deploying-a-nevermined-nft-contract",level:3},{value:"Connecting Nevermined to your NFT contract",id:"connecting-nevermined-to-your-nft-contract",level:2},{value:"Granting and Revoking permissions to manage your NFTs",id:"granting-and-revoking-permissions-to-manage-your-nfts",level:2},{value:"Registering a new asset tokenized via a NFT",id:"registering-a-new-asset-tokenized-via-a-nft",level:2},{value:"Asset price, how much you wanna charge for your NFTs?",id:"asset-price-how-much-you-wanna-charge-for-your-nfts",level:3},{value:"Royalties in the secondary market",id:"royalties-in-the-secondary-market",level:3},{value:"Delegating some permissions a Nevermined Node",id:"delegating-some-permissions-a-nevermined-node",level:3},{value:"Backing up the metadata in immutable storage",id:"backing-up-the-metadata-in-immutable-storage",level:3},{value:"Registering the asset",id:"registering-the-asset",level:3},{value:"Get some details about the asset registered",id:"get-some-details-about-the-asset-registered",level:2},{value:"How a buyer can order a NFT",id:"how-a-buyer-can-order-a-nft",level:2},{value:"The buyer can download some exclusive contents associated with the asset",id:"the-buyer-can-download-some-exclusive-contents-associated-with-the-asset",level:2},{value:"Checking NFT balances",id:"checking-nft-balances",level:2}],m={toc:u};function p(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"how-to-use-nevermined-nfts-via-sdk"},"How to use Nevermined NFTs via SDK"),(0,r.kt)("p",null,"We are gonna see how to use Nevermined NFTs using the SDK-JS. Before starting it\u2019s recommended you take a look at the ",(0,r.kt)("a",{parentName:"p",href:"/docs/nevermined-sdk/getting-started"},"Getting Started")," documentation page where you will be able to find information about how to install the library and initialize it."),(0,r.kt)("h2",{id:"deploying-and-connecting-to-your-own-nft-contract"},"Deploying and connecting to your own NFT contract"),(0,r.kt)("p",null,"In a Nevermined network we pre-deploy some NFT implementations but typically you are gonna want to own your NFT contract. You can deploy your own Nevermined NFT implementation in different ways."),(0,r.kt)("h3",{id:"cloning-a-previously-deployed-contract"},"Cloning a previously deployed contract"),(0,r.kt)("p",null,"Via clonning you can make a copy of an already deploy contract bytecode and deploy it again in a new address. This clone will be a copy of the Smart Contract but not of the state of it. The new contract clonned will be owned by the account clonning the contract. "),(0,r.kt)("admonition",{title:"Clonning saves gas",type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"The advantage of cloning an existing contract is that it is more gas efficient than regular deploying.")),(0,r.kt)(o.Z,{mdxType:"Tabs"},(0,r.kt)(s.Z,{label:"erc-721",value:"erc-721",default:!0,mdxType:"TabItem"},(0,r.kt)("p",null,"Here an example of how you clone a Nevermined ERC-721 contract:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"const cloneAddress = await nevermined.nfts721.getContract.createClone(\n    'My New NFT 721', \n    'SYM', \n    'http://nft.metadata',\n    BigNumber.from(0), // Uncapped\n    [], // Add here any address to be added as a NFT operator\n    deployerAccount\n)\n"))),(0,r.kt)(s.Z,{label:"erc-1155",value:"erc-1155",default:!0,mdxType:"TabItem"},(0,r.kt)("p",null,"Here an example of how you clone a Nevermined ERC-1155 contract:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"const cloneAddress = await nevermined.nfts1155.getContract.createClone(\n    'My New NFT 1155', \n    'SYM', \n    'http://nft.metadata',\n    [], // Add here any address to be added as a NFT operator\n    deployerAccount\n)\n")))),(0,r.kt)("h3",{id:"deploying-a-nevermined-nft-contract"},"Deploying a Nevermined NFT contract"),(0,r.kt)("p",null,"You can deploy a Nevermined NFT any way you prefer using your typical web3 tools. The information about the artifacts of the different Nevermined Smart Contracts deployed in different networks ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/nevermined-io/contracts/#networks"},"can be found in the documentation"),"."),(0,r.kt)("h2",{id:"connecting-nevermined-to-your-nft-contract"},"Connecting Nevermined to your NFT contract"),(0,r.kt)("p",null,"Independently on how you deployed your NFT contract, you can connect your Nevermined instance to it using the following commands:"),(0,r.kt)(o.Z,{mdxType:"Tabs"},(0,r.kt)(s.Z,{label:"erc-721",value:"erc-721",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"await nevermined.contracts.loadNft721(my721NFTContract.address)\n"))),(0,r.kt)(s.Z,{label:"erc-1155",value:"erc-1155",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"await nevermined.contracts.loadNft1155(my1155NFTContract.address)\n")))),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"Whatever contract (ERC-721/ERC-1155) you are going to use, it's important to load it into the ",(0,r.kt)("inlineCode",{parentName:"p"},"nevermined")," api as described above just using the contract address. That will allow you to interact with it.")),(0,r.kt)("h2",{id:"granting-and-revoking-permissions-to-manage-your-nfts"},"Granting and Revoking permissions to manage your NFTs"),(0,r.kt)("p",null,"As we discussed before, in a normal scenario the users want to own their own NFTs. The NFT Smart Contracts represent the digital ownership of a user (represented via wallet) to a digital asset. If you want Nevermined to facilitate the interactivity with your assets, the Smart Contracts could require some permissions in your NFT contract to operate it."),(0,r.kt)("p",null,"This permissions can be granted and revoked always by the contract owner at any point."),(0,r.kt)("p",null,"To allow Nevermined to manage your NFTs or editions you should give permissions into the contract. If the NFT contract is based in the Nevermined NFT contracts you can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"grantOperatorRole")," method for granting permissions and the ",(0,r.kt)("inlineCode",{parentName:"p"},"revokeOperatorRole")," to revoke them:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"// Granting permissions to TransferNFT721Condition\nawait nftContract.grantOperatorRole(transferNft721Condition.address, nftOwner)\n\n// Revoking permissions to TransferNFT721Condition\nawait nftContract.revokeOperatorRole(transferNft721Condition.address, nftOwner)\n")),(0,r.kt)("h2",{id:"registering-a-new-asset-tokenized-via-a-nft"},"Registering a new asset tokenized via a NFT"),(0,r.kt)("p",null,"In Nevermined digital assets can be registered into the platform and tokenized via NFTs. To do that we can associate different implementations based on ERC-721 or ERC-1155 contracts. As discussed above, Nevermined provides some extensions to them that can be used to build different use cases."),(0,r.kt)("p",null,"There are many possibilities that a user can define when registering an asset in Nevermined. You don\u2019t need to use or define all of them, but here we are going to see some of them:"),(0,r.kt)("h3",{id:"asset-price-how-much-you-wanna-charge-for-your-nfts"},"Asset price, how much you wanna charge for your NFTs?"),(0,r.kt)("p",null,"With Nevermined you can define how any asset is gonna be paid and the distribution of that payment via the ",(0,r.kt)("inlineCode",{parentName:"p"},"AssetPrice")," class. That class is flexible and allows to define payments in different ways:"),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"One important clarification, the amounts must be always given in the lower denominator of the token used (for example in ETH is wei). That means if the amount given to the AssetPrice is 1 in ETH that price is 1 wei.")),(0,r.kt)("p",null,"If the asset is free, the price can be establish this way:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"const freePrice = new AssetPrice()\n")),(0,r.kt)("p",null,"Let's say John Doe wants to get 5 USDC:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"const usdcDecimals = 18\nconst assetPrice = new AssetPrice(\n  johnDoeAddress, \n  BigNumber.from(10).pow(usdcDecimals).mul(5), \n  usdcERC20Address\n)\n")),(0,r.kt)("p",null,"In the next example John Doe wants to receive 5 wei of ETH. When the token address provided is the zero address (",(0,r.kt)("inlineCode",{parentName:"p"},"0x0000000000000000000000000000000000000000"),") Nevermined will use as payment the native token of the network where the Smart Contracts are deployed. It means ETH for Ethereum networks, MATIC for Polygon, etc."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"const assetPrice = new AssetPrice(\n  johnDoeAddress, \n  BigNumber.from(5), \n  zeroAddress\n)\n")),(0,r.kt)("p",null,"In the following example John Doe will split the rewards with the marketplace where is selling his NFT. In this case John Doe will get 90 wei of ETH and the marketplace will get 10 wei of ETH:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"const assetPrice = new AssetPrice(\n  new Map([\n    [johnDoeAddress, BigNumber.from(90)],\n    [marketplaceAddress, BigNumber.from(90)],\n  ])\n).setTokenAddress(zeroAddress)\n")),(0,r.kt)("p",null,"And finally let's see how to add the network fees. In Nevermined the Smart Contracts charge a fee for any monetary transaction. This fee needs to be added in the assets price object in this way:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"const assetPrice = new AssetPrice(\n  johnDoeAddress, \n  BigNumber.from(5), \n  zeroAddress\n).addNetworkFees(\n  neverminedFeesReceiver,\n  BigNumber.from(10000) // 1% fee\n)\n")),(0,r.kt)("admonition",{title:"fees",type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"You can read more about this in the ",(0,r.kt)("a",{parentName:"p",href:"/docs/environments/network-fees"},"Network Fees page"),".")),(0,r.kt)("h3",{id:"royalties-in-the-secondary-market"},"Royalties in the secondary market"),(0,r.kt)("p",null,"If as a content creator you want to receive royalties in the secondary market, you must specify them during the asset registration. Royalties and some other asset attributes can not be modified after registration to avoid market adulteration."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"const royaltyAttributes = getRoyaltyAttributes(\n  nevermined,\n  RoyaltyKind.Standard,\n  10000 // It means 1% royalties\n)\n")),(0,r.kt)("p",null,"Nevermined supports different kind of royalties schemes where the static scheme is the most common. Additional schemes can be plugged as Smart Contracts allowing to have more flexible scenarios (bounding curves, etc)."),(0,r.kt)("h3",{id:"delegating-some-permissions-a-nevermined-node"},"Delegating some permissions a Nevermined Node"),(0,r.kt)("p",null,"The trading between seller and buyer in a Nevermined ecosystem can be done directly between them in a peer to peer fashion. But to finalize all the transactions both users need to be online to accept the asset transactions. Because of that, it is convenient to delegate some permissions to a Nevermined Node (aka Node). The Node is an element in the Nevermined architecture that facilitates the usage. Nodes can be executed by Nevermined or anyone else and have a limited permissions to trigger some transactions."),(0,r.kt)("p",null,"During the registration of an asset this permissions can be granted adding a one or many Nodes addresses to the providers option.\nThe addition or removal of permissions to a Node or group of Nodes can be done during the registration or afterwards. "),(0,r.kt)("h3",{id:"backing-up-the-metadata-in-immutable-storage"},"Backing up the metadata in immutable storage"),(0,r.kt)("p",null,"In Nevermined when an asset is registered the user doing that registration provides some metadata describing the asset. It helps to identify and discover that asset, and also from a user point of view is useful to understand what the asset is about.\nBy default all this metadata is stored in Metadata/Marketplace APIs. These are services recording metadata off-chain (not in a blockchain but in a database or standard repository) to facilitate search and discovery of assets about specific domains. Typically a Marketplace built on top of Nevermined about a specific topic (like Health or Finance) runs an independent Metadata/Marketplace API to record information about assets related to that topic."),(0,r.kt)("p",null,"Because of the important function of the metadata, Nevermined facilitates the option of backing up the asset metadata in an immutable storage system (like IPFS or Filecoin). This means the asset metadata is stored in the Metadata repository and additionally into IPFS for example."),(0,r.kt)("p",null,"This option can be achieved by giving the ",(0,r.kt)("inlineCode",{parentName:"p"},"PublishMetadata")," option to the create method of the NFT. For example, using ",(0,r.kt)("inlineCode",{parentName:"p"},"PublishMetadata.IPFS")," allows to store the metadata in the Metadata API and in IPFS."),(0,r.kt)("h3",{id:"registering-the-asset"},"Registering the asset"),(0,r.kt)("p",null,"As you can see Nevermined is very flexible in the way that allows to configure several options that are convinient depending on different use cases. Let's put all of this together:"),(0,r.kt)(o.Z,{mdxType:"Tabs"},(0,r.kt)(s.Z,{label:"erc-721",value:"erc-721",default:!0,mdxType:"TabItem"},(0,r.kt)("p",null,"Registering a Nevermined NFT (ERC-721):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"\nconst nftAttributes = NFTAttributes.getNFT721Instance({\n    metadata,\n    serviceTypes: ['nft-sales', 'nft-access'],\n    nftContractAddress: myERC721Contract.address\n})\nconst ddo = await nevermined.nfts721.create(\n  nftAttributes, \n  johnDoeAccount\n)\n\n"))),(0,r.kt)(s.Z,{label:"erc-1155",value:"erc-1155",default:!0,mdxType:"TabItem"},(0,r.kt)("p",null,"Registering a Nevermined NFT (ERC-1155):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"\nconst royaltyAttributes = getRoyaltyAttributes(\n  nevermined,\n  RoyaltyKind.Standard,\n  100000 // 10% royalties in the secondary market\n)\n\nconst assetAttributes = AssetAttributes.getInstance({\n  metadata, // Some asset metadata\n  price: assetPrice, // As we defined before\n  serviceTypes: ['nft-sales', 'nft-access'],\n  providers: [config.neverminedNodeAddress] // The address of the Nevermined Node with permissions to interact with the asset\n})\n\nconst nftAttributes = NFTAttributes.getNFT1155Instance({\n  ...assetAttributes,\n  nftContractAddress: myERC1155Contract, // The address of the NFT Contract attached to the asset\n  amount: numberEditions,\n  royaltyAttributes\n})            \n\nconst ddo = await nevermined.nfts1155.create(\n    nftAttributes,\n    johnDoeAccount, // The account of the user registering the asset\n    PublishMetadata.IPFS\n) \n")))),(0,r.kt)("p",null,"Once an asset is registered the create method will return a Decentralized Document Object (aka DDO). This object includes some metadata of the asset registered and a reference to the unique identifier of the asset in a Nevermined network, the Decentralized Identifier (aka DID)."),(0,r.kt)("p",null,"We will use that DID always to identify one specific asset on Nevermined."),(0,r.kt)("h2",{id:"get-some-details-about-the-asset-registered"},"Get some details about the asset registered"),(0,r.kt)("p",null,"Having the DDO and DID is possible to fetch some information about the asset.\nIf we want to get the metadata we use the resolve method:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"// By default it will get the Metadata from the Metadata API\nconst metadata = await nevermined.assets.resolve(ddo.id)\n\n// Here we force to fetch the Metadata from IPFS\nconst metadata = await nevermined.assets.resolve(\n  ddo.id, \n  DIDResolvePolicy.ImmutableFirst\n)\n")),(0,r.kt)("p",null,"The resolve method accepts an optional parameter in the second position. That is the policy used to resolve the metadata for a DID given. Remember before we spoke about the option of storing the Metadata off-chain and on-chain, with this option we can specify how we prioritize the resolution of the metadata. Depending on the use case that gives us the option to try to resolve that metadata from the immutable data store first (like IPFS), the Metadata API or force only one of these options."),(0,r.kt)("p",null,"And if we want to fetch some on-chain information about the NFT:"),(0,r.kt)(o.Z,{mdxType:"Tabs"},(0,r.kt)(s.Z,{label:"erc-721",value:"erc-721",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"const details = await nevermined.nfts721.details(ddo.id)\n"))),(0,r.kt)(s.Z,{label:"erc-1155",value:"erc-1155",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"const details = await nevermined.nfts1155.details(ddo.id)\n")))),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"details")," method of the NFT apis will provide information about:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The mint cap"),(0,r.kt)("li",{parentName:"ul"},"The total supply of the nft"),(0,r.kt)("li",{parentName:"ul"},"The royalties scheme and amount"),(0,r.kt)("li",{parentName:"ul"},"The owner of the NFT contract")),(0,r.kt)("h2",{id:"how-a-buyer-can-order-a-nft"},"How a buyer can order a NFT"),(0,r.kt)("p",null,"Having a registered asset with nfts associated to it, a buyer can order then directly:"),(0,r.kt)(o.Z,{mdxType:"Tabs"},(0,r.kt)(s.Z,{label:"erc-721",value:"erc-721",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"const agreementId = await nevermined.nfts721.order(ddo.id, buyerAccount)\n"))),(0,r.kt)(s.Z,{label:"erc-1155",value:"erc-1155",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"const numberEditions= BigNumber.from(1) // Higher if we want to purchase more than 1 edition\nconst agreementId = await nevermined.nfts1155.order(ddo.id, numberEditions, buyerAccount)\n")))),(0,r.kt)("p",null,"The order method will return an ",(0,r.kt)("inlineCode",{parentName:"p"},"agreementId"),". This is a unique identifier associated with this purchase transaction. The ",(0,r.kt)("inlineCode",{parentName:"p"},"agreementId")," can be used later to fetch on-chain information about the status of the order."),(0,r.kt)("h2",{id:"the-buyer-can-download-some-exclusive-contents-associated-with-the-asset"},"The buyer can download some exclusive contents associated with the asset"),(0,r.kt)("p",null,"If everything went well during the ",(0,r.kt)("inlineCode",{parentName:"p"},"order")," step, the buyer can claim for the NFT:"),(0,r.kt)(o.Z,{mdxType:"Tabs"},(0,r.kt)(s.Z,{label:"erc-721",value:"erc-721",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"const result = await nevermined.nfts721.claim(\n    agreementId,\n    publisherAddress,\n    buyerAddress\n)\n"))),(0,r.kt)(s.Z,{label:"erc-1155",value:"erc-1155",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"const result = await nevermined.nfts1155.claim(\n    agreementId,\n    publisherAddress,\n    buyerAddress,\n    numberEditions\n)\n")))),(0,r.kt)("p",null,"At this point the buyer should receive the NFT and the seller the token payment described in the ",(0,r.kt)("inlineCode",{parentName:"p"},"AssetPrice")," object.\nBecause the buyer is now a NFT holder, if the asset has associated some exclusive contents they can be downloaded using the access command:"),(0,r.kt)(o.Z,{mdxType:"Tabs"},(0,r.kt)(s.Z,{label:"erc-721",value:"erc-721",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"await nevermined.nfts721.access(\n    ddo.id,\n    user,\n    '/tmp/my-files'\n)\n"))),(0,r.kt)(s.Z,{label:"erc-1155",value:"erc-1155",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"await nevermined.nfts1155.access(\n    ddo.id,\n    buyerAccount,\n    '/tmp/my-files'\n)\n")))),(0,r.kt)("p",null,"All the files downloaded should be now in the ",(0,r.kt)("inlineCode",{parentName:"p"},"/tmp/my-files")," folder."),(0,r.kt)("h2",{id:"checking-nft-balances"},"Checking NFT balances"),(0,r.kt)("p",null,"Any user can interact directly with the NFT contracts directly to get contract balances, but that is also possible via Nevermined API:"),(0,r.kt)(o.Z,{mdxType:"Tabs"},(0,r.kt)(s.Z,{label:"erc-721",value:"erc-721",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"const balance = await nevermined.nfts721.balance(\n  johnDoeAddress\n)\n"))),(0,r.kt)(s.Z,{label:"erc-1155",value:"erc-1155",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"const balance = await nevermined.nfts1155.balance(\n  ddo.id, \n  johnDoeAddress\n)\n")))))}p.isMDXComponent=!0}}]);